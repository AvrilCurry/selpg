# selpg
A Command Line Program



设计说明：
	这个命令行程序的设计其实就是为了实现selpg命令，在给出的文档中已经有详细的介绍，不过那里是使用C语言来实现的，而这里则要求使用go语言来实现。
	1） 由于命令行是需要自己解析的，所以我们需要根据输入的命令解析得到给出的option参数。那这里就需要先了解命令有些option: [-s, -e, -l, -f, -d],其中-s, -e是必须要有的，而-l,-f,-d可以根据实际来选择。文档中option需要参数是直接写在后面，我这里是隔一个空格。还有一个参数，是在最后，一个字符串，表示一个输入文件，也需要解析命令得到。其实，这里需要注意：输入文件有时并不是在命令行最后的位置，比如[selpg -s 1 -e 3 -l 66 inputfile > outputfile 2> error.log]这个命令，但当你试图通过os.Args来获取时，你是得不到的，os.Args最后一个元素就是inputfile。原来，这是Linux自己会自动处理的，我们并不需要理会，只需指定对应的文件的位置就行，其他的还有othercommand，还有管道符[|]。这些options的含义就不多说，文档里有，所以，最后只理清一下这个程序的用处：通过在终端输入命令行，程序会解析命令行，得到options以及对应的参数，然后程序根据这些options和参数来执行对应的操作。
	2）命令行的解析：这里不会详细说明这种情况，只是简单说明。由于os.Args的第一个元素是程序名，因此从第二个元素开始解析，命令行一定要包含-s -d，顺序不能乱，而且后面一定要有参数，不然会报错，同时参数的值一定要有效。
	3）go中的输入输出流。这里我是使用bufio里面的NewReader(fin)来生成一个bufio.Reader对象进行读取。如果有输入文件，fin=os.Open(inputfile);没有输入文件，fin=os.Stdin。对于os.Stdin，如果没有 < inputfile，那么就会默认是输入是在屏幕上；有的话就是从对应文件输入。这对于输出也是一样的，如果有 > outputfile 或者 2> error.log ，那么输出是在文件中；如果没有，那么输出是在屏幕上。
	4）结果截图我是按照文档中的顺序执行的，文档中总共有14条命令，我没有执行第13条命令，是关于-d option，所以那里只有13个文件夹。每条命令的结果与文件夹命名是一一对应的，就是第一条命令的结果是在文件夹1中，如此类推。
